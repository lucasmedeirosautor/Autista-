<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Como Fazer a Caneca Perfeita</title>

  <!-- Fontes e Estilos -->
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600&family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    html {
      scroll-behavior: smooth;
    }

    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      background-color: #fffaf8;
      overflow-x: hidden;
    }

    section {
      padding: 80px 20px;
      text-align: center;
      transition: background-color 1s ease;
    }

    h1, h2, h3 {
      font-family: 'Playfair Display', serif;
      letter-spacing: 1px;
    }

    /* ======= FUNDOS PREMIUM POR BLOCO ======= */
    section:nth-of-type(1) { background: linear-gradient(135deg, #fce4ec, #f8cdda); } /* Rose Gold */
    section:nth-of-type(2) { background: linear-gradient(135deg, #fff8e1, #f7d56e); } /* Dourado */
    section:nth-of-type(3) { background: linear-gradient(135deg, #1a1a1a, #2e2e2e); color: #fff; } /* Preto Brilhante */
    section:nth-of-type(4) { background: linear-gradient(135deg, #fff, #fafafa); } /* Branco Perolado */
    section:nth-of-type(5) { background: linear-gradient(135deg, #f8cdda, #fbeee6); } /* Rose Gold Final */

    /* ======= ANIMAÇÕES DE ENTRADA ======= */
    .hidden {
      opacity: 0;
      transform: translateX(60px);
      transition: all 1s ease-out;
    }

    .show {
      opacity: 1;
      transform: translateX(0);
    }

    /* ======= BOTÕES PREMIUM ======= */
    .btn-premium {
      display: inline-block;
      padding: 15px 35px;
      border-radius: 50px;
      background: linear-gradient(45deg, #d4af37, #f5e6b3);
      color: #000;
      font-weight: 600;
      text-decoration: none;
      box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
      transition: all 0.3s ease;
    }

    .btn-premium:hover {
      transform: scale(1.05);
      box-shadow: 0 0 25px rgba(212, 175, 55, 0.8);
    }

    /* ======= CONTADORES ======= */
    .counter-box {
      font-size: 1.2em;
      margin-top: 10px;
      font-weight: 600;
    }

    /* ======= NOTIFICAÇÕES ======= */
    .purchase-toast {
      position: fixed;
      bottom: 30px;
      left: 30px;
      background: rgba(255, 255, 255, 0.85);
      color: #000;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 500;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
      animation: fadeSlideIn 0.8s ease forwards;
      display: none;
      z-index: 9999;
    }

    @keyframes fadeSlideIn {
      from { opacity: 0; transform: translateY(40px); }
      to { opacity: 1; transform: translateY(0); }
    }

  </style>
</head>

<body><!-- ===== PARTE 2: Estilos por bloco + animações de entrada (Cole logo após <div class="wrap">) ===== -->
<style>
  /* backgrounds premium específicos (mais controle que nth-of-type) */
  .bg-rose { background: linear-gradient(135deg, #fbe8ec 0%, #f7d7d0 100%); color: #1a1a1a; }
  .bg-gold { background: linear-gradient(135deg, #fff8e6 0%, #f6d57a 100%); color: #111; }
  .bg-black { background: linear-gradient(135deg, #0b0b0b 0%, #262626 100%); color: #fff; }
  .bg-pearl { background: linear-gradient(135deg, #ffffff 0%, #fbfbfb 100%); color: #111; }

  /* override de padding/spacing por bloco (visual premium) */
  .wrap > header, .wrap > section, .wrap > footer, .wrap > aside {
    border-radius: 18px;
    margin-bottom: 22px;
    padding: 34px;
    transition: background 0.9s ease, transform 0.7s cubic-bezier(.2,.9,.2,1), box-shadow .7s ease;
  }

  /* card sombreado discretamente */
  .wrap > header, .wrap > aside, .wrap > section:not(#gallery) {
    box-shadow: 0 20px 60px rgba(8,6,6,0.18);
  }

  /* animação: entrar da direita (aplicada via JS adicionando classe .hidden/.show) */
  .hidden-sect {
    opacity: 0;
    transform: translateX(60px);
    will-change: transform, opacity;
  }
  .show-sect {
    opacity: 1;
    transform: translateX(0);
    transition: transform 0.9s cubic-bezier(.2,.9,.2,1), opacity 0.9s ease;
  }

  /* títulos premium por seção */
  .wrap h2, .wrap h1 {
    margin: 0 0 12px 0;
    line-height: 1.06;
  }
  .wrap h2 {
    font-size: 22px;
    font-family: 'Playfair Display', serif;
    letter-spacing: 0.6px;
  }

  /* botão premium — mix com teu .btn existente (mantém comportamento) */
  .btn-premium {
    border-radius: 999px;
    padding: 14px 28px;
    font-weight: 800;
    box-shadow: 0 10px 30px rgba(0,0,0,0.18);
    transition: transform .25s ease, box-shadow .25s ease;
  }
  .btn-premium:hover { transform: translateY(-3px); box-shadow: 0 18px 50px rgba(0,0,0,0.28); }

  /* mockups: leve flutuação e máscara brilhante por cima */
  .mockup {
    overflow: hidden;
    border-radius: 14px;
    position: relative;
    transition: transform .6s cubic-bezier(.2,.9,.2,1), box-shadow .6s ease;
  }
  .mockup img { display:block; width:100%; height:100%; object-fit:cover; }
  .mockup.float {
    animation: floatY 6s ease-in-out infinite;
  }
  @keyframes floatY {
    0% { transform: translateY(0); }
    50% { transform: translateY(-6px); }
    100% { transform: translateY(0); }
  }

  /* destaque visual para o contador e preço (pulse discreto) */
  .price { transition: transform .4s ease; }
  .price.pulse { animation: pricePulse 2.2s ease-in-out infinite; }
  @keyframes pricePulse {
    0% { transform: scale(1); filter: drop-shadow(0 6px 18px rgba(212,162,74,0.06)); }
    50% { transform: scale(1.03); filter: drop-shadow(0 18px 50px rgba(212,162,74,0.12)); }
    100% { transform: scale(1); filter: drop-shadow(0 6px 18px rgba(212,162,74,0.06)); }
  }

  /* responsividade: reduz padding em telas pequenas */
  @media (max-width: 980px) {
    .wrap > header, .wrap > aside, .wrap > section, .wrap > footer { padding: 22px; }
  }
</style>

<script>
  (function(){
    // Aplica classes de fundo em ordem premium: rose -> gold -> black -> pearl -> rose...
    const bgClasses = ['bg-rose','bg-gold','bg-black','bg-pearl'];
    // Seleciona blocos que vamos estilizar (mantemos tudo que já existe)
    const selectors = ['header', 'section', 'aside.book-card', 'footer'];
    // cria lista linear de elementos dentro da .wrap que correspondem aos seletores (na ordem do DOM)
    const wrap = document.querySelector('.wrap');
    if(!wrap) return;

    // coletar nodes que faremos efeito (manter ordem do DOM)
    const nodes = [];
    wrap.childNodes.forEach(n => {
      if(n.nodeType !== 1) return; // elemento
      const tag = n.tagName.toLowerCase();
      if(tag === 'header' || tag === 'footer' || (tag === 'aside' && n.classList.contains('book-card')) || tag === 'section') {
        nodes.push(n);
      }
    });

    // Atribui background cyclicamente e aplica classes de animação inicial
    nodes.forEach((el, idx) => {
      // Evitar sobrescrever se já tiveres uma classe de background manual
      const hasBg = el.classList.contains('bg-rose') || el.classList.contains('bg-gold') || el.classList.contains('bg-black') || el.classList.contains('bg-pearl');
      if(!hasBg) {
        const cls = bgClasses[idx % bgClasses.length];
        el.classList.add(cls);
      }
      // adiciona classe escondida para animação de entrada
      el.classList.add('hidden-sect');

      // marca elementos importantes com botões premium
      // se o elemento contém .btn ou .btn.ghost, adicione estilo premium
      const btns = el.querySelectorAll('.btn');
      btns.forEach(b => b.classList.add('btn-premium'));
    });

    // IntersectionObserver para revelar (rolando da direita)
    const io = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if(entry.isIntersecting) {
          const el = entry.target;
          // small stagger depending on position within node
          const children = Array.from(el.querySelectorAll(':scope > *'));
          // reveal parent
          el.classList.add('show-sect');
          el.classList.remove('hidden-sect');
          // reveal inner children with small delays
          children.forEach((child, i) => {
            child.style.transition = `opacity 0.8s ease ${i*90}ms, transform 0.8s cubic-bezier(.2,.9,.2,1) ${i*90}ms`;
            child.style.opacity = 1;
            child.style.transform = 'translateX(0)';
          });
          io.unobserve(el);
        }
      });
    }, { threshold: 0.14, rootMargin: '0px 0px -8% 0px' });

    // Observe each collected node
    nodes.forEach((n, idx) => {
      // slight initial offset for children to allow staggered reveal
      n.querySelectorAll('*').forEach(ch => {
        ch.style.opacity = 0;
        ch.style.transform = 'translateX(18px)';
      });
      io.observe(n);
    });

    // Add subtle float animation to mockups for visual premium
    const mockups = document.querySelectorAll('.mockup');
    mockups.forEach((m, i) => {
      m.classList.add('float');
      // add slight rotate on hover
      m.addEventListener('mouseenter', () => m.style.transform = 'translateY(-8px) rotate(-0.4deg) scale(1.02)');
      m.addEventListener('mouseleave', () => m.style.transform = '');
    });

    // aplica pulse no price (se existir)
    const priceEl = document.querySelector('.price');
    if(priceEl) priceEl.classList.add('pulse');

    // Accessibility: enable keyboard focus outlines for .btn-premium
    document.querySelectorAll('.btn-premium').forEach(b => {
      b.addEventListener('focus', ()=> b.style.boxShadow = '0 0 0 4px rgba(212,162,74,0.12)');
      b.addEventListener('blur', ()=> b.style.boxShadow = '');
    });

    // tiny optimization: remove pre-existing legacy reveal classes to avoid conflicts (não remove conteúdo)
    document.querySelectorAll('.reveal').forEach(r => {
      // keep class but avoid duplicate transition fights
      r.style.transition = 'none';
      // allow intersection observer above to handle reveal
    });

    // Done - nodes now styled + will animate when scrolled into view
  })();
</script>
<!-- ===== FIM PARTE 2 ===== -->
  <!-- ===== PARTE 3: Contador dinâmico de compradores + toasts ===== -->
<style>
  /* Toasts simples e premium */
  .toast {
    position: fixed;
    bottom: 26px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 248, 230, 0.96);
    color: #111;
    padding: 14px 22px;
    border-radius: 12px;
    box-shadow: 0 14px 38px rgba(0,0,0,0.18);
    font-weight: 600;
    font-family: 'Poppins', sans-serif;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.6s ease, transform 0.6s ease;
    z-index: 9999;
  }
  .toast.show {
    opacity: 1;
    transform: translateX(-50%) translateY(-12px);
  }
</style>

<script>
  (function(){
    // Inicializa contador persistente
    const storageKey = 'contador_compradores';
    let count = parseInt(localStorage.getItem(storageKey)) || 72; // valor inicial
    const contadorEl = document.querySelector('#contador');
    if(contadorEl) contadorEl.textContent = count;

    // Nomes fictícios para toasts
    const firstNames = ["Lucas","Mariana","Rafael","Julia","Carlos","Fernanda","Thiago","Amanda","Gabriel","Patrícia"];
    const lastNames = ["Silva","Santos","Oliveira","Pereira","Costa","Almeida","Medeiros","Rodrigues","Lima","Gomes"];

    // Função para gerar nome + sobrenome aleatório
    function randomName() {
      const first = firstNames[Math.floor(Math.random()*firstNames.length)];
      const last = lastNames[Math.floor(Math.random()*lastNames.length)];
      return `${first} ${last}`;
    }

    // Cria toast no DOM
    function showToast(name) {
      const t = document.createElement('div');
      t.className = 'toast';
      t.textContent = `${name} acabou de adquirir o eBook!`;
      document.body.appendChild(t);
      setTimeout(() => t.classList.add('show'), 50);
      setTimeout(() => {
        t.classList.remove('show');
        setTimeout(() => t.remove(), 700);
      }, 4000);
    }

    // Incremento automático
    function incrementCounter() {
      const increment = 1; // pode variar se quiser
      count += increment;
      if(contadorEl) contadorEl.textContent = count;
      localStorage.setItem(storageKey, count);
      // exibe toast
      showToast(randomName());
    }

    // Intervalo aleatório entre 10 e 25 segundos
    function scheduleNext() {
      const ms = 10000 + Math.random()*15000;
      setTimeout(() => {
        incrementCounter();
        scheduleNext();
      }, ms);
    }

    // Inicia loop
    scheduleNext();
  })();
</script>
<!-- ===== FIM PARTE 3 ===== -->
